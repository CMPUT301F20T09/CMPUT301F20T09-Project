package com.example.pocketbook.util;

import android.util.Log;

import com.example.pocketbook.model.Book;
import com.example.pocketbook.model.MeetingDetails;
import com.example.pocketbook.model.Notification;
import com.example.pocketbook.model.Request;
import com.example.pocketbook.model.User;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Random;

// TODO: for Request and Notification set date format to have milliseconds (for sorting),
//  but have the classes' get...Date() methods return a hour-minute formatted string

// TODO: extract common methods to single method (like book owner and user email methods)

// TODO: Parser request book breaks; handle null book objects / Parser-invalid book objects

/**
 * Parser class ensures the validity of the
 * objects and text within the app
 */
public class Parser {

    //////////////////////////////////////// GENERAL PARSER ////////////////////////////////////////

    /**
     * This checks if an email is valid
     * @param email email
     * @return
     *      true if email is formatted correctly, not null or an empty string, and is lowercase
     *      false otherwise
     */
    public static boolean isValidEmail(String email) {

        if (email == null) {
            return false;
        }

        int at_index = -1;
        int at_count = 0;
        int dot_index = -1;
        int emailLength = email.length();

        // if the email is shorter than a@b.c or longer than 100 chars
        if ((emailLength < 5) || (emailLength > 100)) {
            return false;
        }

        // for each char in the email
        for (int i = 0; i < emailLength; i++) {

            // if the char is @ and @ is not the first char
            if ((email.charAt(i) == '@') && (i > 0)) {
                // set at_index to i when i is found & increment at_count
                if (at_index == -1) {
                    at_index = i;
                }
                at_count += 1;  // increment at_count
            }
            // if the char is . and it's at least one char away from @
            if ((email.charAt(i) == '.') && (i != (emailLength - 1)) && (i > (at_index + 1))) {
                dot_index = i;
            }
        }
        // return true if there's only one @ and at least one . after the @
        return (at_count == 1) && (dot_index > -1) && email.equals(email.toLowerCase());
    }

    /////////////////////////////////////////  BOOK PARSER /////////////////////////////////////////

    private static List<String> conditions = Arrays.asList("GREAT",
            "GOOD", "FAIR", "ACCEPTABLE");

    private static List<String> statuses = Arrays.asList("AVAILABLE",
            "REQUESTED", "ACCEPTED", "BORROWED");

    private static List<String> notificationTypes = Arrays.asList("BOOK_REQUESTED",
            "REQUEST_ACCEPTED", "REQUEST_DECLINED", "RETURN_REQUESTED", "LOCATION_SPECIFIED");

    /**
     * This returns a valid Book object if arguments are valid, null otherwise
     * @param id book id that was randomly generated by Firebase
     * @param title book title
     * @param author book author
     * @param isbn book isbn
     * @param owner app user that owns the book
     * @param status book status; can be "AVAILABLE", "REQUESTED", "ACCEPTED" or "BORROWED"
     * @param comment app user's optional comments about the book
     * @param condition book condition; can be "GREAT", "GOOD", "FAIR" or "ACCEPTABLE"
     * @param photo name of app user's optional photo for the book
     * @param requesters
     * @return
     *      valid Book object if arguments are valid
     *      null otherwise
     */
    public static Book parseBook(String id, String title, String author, String isbn, String owner,
                                 String status, String comment, String condition, String photo,
                                 ArrayList<String> requesters) {

        // return null if non-optional fields are null
        if ((id == null) || (title == null) || (author == null) || (isbn == null)
                || (owner == null) || (status == null) || (condition == null)) {
            return null;
        }

        // TODO: requesters

        // trim all values
        id = id.trim();
        title = title.trim();
        author = author.trim();
        isbn = isbn.trim();
        owner = owner.trim();
        status = status.trim().toUpperCase();
        comment = (comment == null) ? "" : comment.trim();  // replace null with empty string
        condition = condition.trim().toUpperCase();
        photo = (photo == null) ? "" : photo.trim();  // replace null with empty string

        // if all fields (other than isbn) are valid
        if (isValidBookId(id) && isValidBookTitle(title) && isValidBookAuthor(author)
                && isValidBookOwner(owner) && isValidBookStatus(status)
                && isValidBookCondition(condition) && isValidBookPhoto(photo)) {

            // try to convert isbn to isbn13
            isbn = convertToIsbn13(isbn);

            // return null if isbn conversion is invalid
            if (isbn == null) {
                return null;
            }

            // return a new Book object if all fields are valid
            return new Book(id, title, author, isbn, owner,
                    status, comment, condition, photo, requesters);
        }

        // return null if not all fields are valid
        return null;
    }

    /**
     * This checks whether or not a book HashMap object contains valid Book data
     * @param bookMapObject a HashMap object containing Book data
     * @return
     *      true if the book HashMap object contains valid Book data
     *      false otherwise
     */
    public static boolean isValidBook(HashMap<String, Object> bookMapObject) {
        // get all values
        String id = (String) bookMapObject.get("id");
        String title = (String) bookMapObject.get("title");
        String author = (String) bookMapObject.get("author");
        String isbn = (String) bookMapObject.get("isbn");
        String owner = (String) bookMapObject.get("owner");
        String status = (String) bookMapObject.get("status");
        String comment = (String) bookMapObject.get("comment");
        String condition = (String) bookMapObject.get("condition");
        String photo = (String) bookMapObject.get("photo");

        // TODO: requesters

        // if all fields (other than isbn) are valid
        if (isValidBookId(id) && isValidBookTitle(title) && isValidBookAuthor(author)
                && isValidBookOwner(owner) && isValidBookStatus(status)
                && isValidBookComment(comment) && isValidBookCondition(condition)
                && isValidBookPhoto(photo)) {

            // try to convert isbn to isbn13
            isbn = convertToIsbn13(isbn);

            // return whether or not all fields are valid
            return (isbn != null);
        }

        Log.e("PARSER_VALID_BOOK", id + " is not valid!"
                + " " + "id:" + isValidBookId(id)
                + " " + "title:" + isValidBookTitle(title)
                + " " + "author:" + isValidBookAuthor(author)
                + " " + "owner:" + isValidBookOwner(owner)
                + " " + "status:" + isValidBookStatus(status)
                + " " + "comment:" + isValidBookComment(comment)
                + " " + "condition:" + isValidBookCondition(condition)
                + " " + "photo:" + isValidBookPhoto(photo)
        );

        // return false if not all fields are valid
        return false;
    }

    /**
     * This checks whether or not a book object contains valid Book data
     * @param bookObject a book object containing Book data
     * @return
     *      true if the book object contains valid Book data
     *      false otherwise
     */
    public static boolean isValidBookObject(Book bookObject) {
        // get all values
        String id = bookObject.getId();
        String title = bookObject.getTitle();
        String author = bookObject.getAuthor();
        String isbn = bookObject.getISBN();
        String owner = bookObject.getOwner();
        String status = bookObject.getStatus();
        String comment = bookObject.getComment();
        String condition = bookObject.getCondition();
        String photo = bookObject.getPhoto();

        // TODO: requesters

        // if all fields (other than isbn) are valid
        if (isValidBookId(id) && isValidBookTitle(title) && isValidBookAuthor(author)
                && isValidBookOwner(owner) && isValidBookStatus(status)
                && isValidBookComment(comment) && isValidBookCondition(condition)
                && isValidBookPhoto(photo)) {

            // try to convert isbn to isbn13
            isbn = convertToIsbn13(isbn);

            // return whether or not all fields are valid
            return (isbn != null);
        }

        Log.e("PARSER_VALID_BOOK", id + " is not valid!"
                + " " + "id:" + isValidBookId(id)
                + " " + "title:" + isValidBookTitle(title)
                + " " + "author:" + isValidBookAuthor(author)
                + " " + "owner:" + isValidBookOwner(owner)
                + " " + "status:" + isValidBookStatus(status)
                + " " + "comment:" + isValidBookComment(comment)
                + " " + "condition:" + isValidBookCondition(condition)
                + " " + "photo:" + isValidBookPhoto(photo)
        );

        // return false if not all fields are valid
        return false;
    }

    /**
     * This returns whether or not potential book fields are valid
     * @param id book id that was randomly generated by Firebase
     * @param title book title
     * @param author book author
     * @param isbn book isbn
     * @param owner app user that owns the book
     * @param status book status; can be "AVAILABLE", "REQUESTED", "ACCEPTED" or "BORROWED"
     * @param comment app user's optional comments about the book
     * @param condition book condition; can be "GREAT", "GOOD", "FAIR" or "ACCEPTABLE"
     * @param photo name of app user's optional photo for the book
     * @return
     *      true if arguments are valid
     *      false otherwise
     */
    public static boolean isValidBookData(String id, String title, String author, String isbn,
                                          String owner, String status, String comment,
                                          String condition, String photo,
                                          ArrayList<String> requesters) {

        // return false if non-optional fields are null
        if ((id == null) || (title == null) || (author == null) || (isbn == null)
                || (owner == null) || (status == null) || (condition == null)) {
            return false;
        }

        // TODO: requesters

        // if all fields (other than isbn) are valid
        if (isValidBookId(id) && isValidBookTitle(title) && isValidBookAuthor(author)
                && isValidBookOwner(owner) && isValidBookStatus(status)
                && isValidBookCondition(condition) && isValidBookPhoto(photo)) {

            // try to convert isbn to isbn13
            isbn = convertToIsbn13(isbn);

            // return true if isbn conversion is valid
            return (isbn != null);
        }

        // return false if not all fields are valid
        return false;
    }


    /**
     * This checks if a new book id is valid
     * @param id empty string that will be replaced by a real id when book is added to Firebase
     * @return
     *      true if empty string
     *      false otherwise
     */
    public static boolean isValidNewBookId(String id) {
        // newly created local books will have "" ids
        return (id != null) && (id.trim().length() == 0);
    }

    /**
     * This checks if a book id is valid
     * @param id book id that was randomly generated by Firebase
     * @return
     *      true if valid id
     *      false otherwise
     */
    public static boolean isValidBookId(String id) {
        return ((id != null) && (id.trim().length() > 0));
    }

    /**
     * This checks if a book title is valid
     * @param title book title
     * @return
     *      true if title is not null or an empty string
     *      false otherwise
     */
    public static boolean isValidBookTitle(String title) {
        return ((title != null) && (title.trim().length() > 0));
    }

    /**
     * This checks if a book author is valid
     * @param author book author
     * @return
     *      true if author is not null or an empty string
     *      false otherwise
     */
    public static boolean isValidBookAuthor(String author) {
        return ((author != null) && (author.trim().length() > 0));
    }

    public static boolean isValidBookIsbn(String isbn) {
        return (isValidIsbn10(isbn) || isValidIsbn13(isbn));
    }

    /**
     * This checks if a book owner is valid
     * @param owner app user that owns the book
     * @return
     *      true if owner is formatted correctly, not null or an empty string, and is lowercase
     *      false otherwise
     */
    public static boolean isValidBookOwner(String owner) {
        return isValidEmail(owner);
    }

    /**
     * This checks if the status specified is in the list of statuses
     * @param status book status
     * @return
     *      true if status is in ["AVAILABLE", "REQUESTED", "ACCEPTED", "BORROWED"]
     *      false otherwise
     */
    public static boolean isValidBookStatus(String status) {
        return statuses.contains(status);
    }

    /**
     * This checks if the condition specified is in the list of conditions
     * @param condition book condition
     * @return
     *      true if condition is in ["GREAT", "GOOD", "FAIR", "ACCEPTABLE"]
     *      false otherwise
     */
    public static boolean isValidBookCondition(String condition) {
        return conditions.contains(condition);
    }

    public static boolean isValidBookComment(String comment) {
        return (comment != null);
    }

    /**
     * This checks if a photo name is valid
     * @param photo name of app user's optional photo for the book
     * @return
     *      true if photo is an empty string or a jpg file
     *      false otherwise
     */
    public static boolean isValidBookPhoto(String photo) {
        if (photo == null) {
            return false;
        }
        return photo.equals("") || (photo.endsWith(".jpg") && (photo.length() > 4));
    }

    /**
     * This checks if a string is not a number
     * @param text string to be converted to number
     * @return
     *      false if input is a number
     *      true otherwise
     */
    public static boolean isNotDigit(String text) {
        try {
            Long.parseLong(text);
            return false;
        } catch (NumberFormatException ex) {
            return true;
        }
    }

    /**
     * This checks if an isbn is valid isbn10
     * @param isbn book isbn
     * @return
     *      true if isbn is valid isbn10
     *      false otherwise
     */
    public static boolean isValidIsbn10(String isbn) {
        if (isbn == null) {
            return false;
        }

        // remove spaces and dashes from isbn
        isbn = isbn.replace("-", "")
                .replace(" ", "").toUpperCase();

        int isbnLength = isbn.length();

        if (isbnLength != 10) {  // isbn10 has to be 10 digits
            return false;
        }

        String lastCharacter = Character.toString(isbn.charAt(isbnLength - 1));
        boolean lastCharacterIsX = lastCharacter.equals("X");
        String isbnWithoutLastCharacter = isbn.substring(0, isbnLength - 1);

        // return false if the first 9 isbn digits are not numbers
        // OR if the last character is not a digit and is not 'X'
        if (isNotDigit(isbnWithoutLastCharacter) ||
                ((isNotDigit(lastCharacter)) && !(lastCharacterIsX))) {
            return false;
        }

        // compute the weighted sum of the first 9 isbn digits
        int sum = 0;
        for (int index = 0; index < 9; index++) {
            int digit = isbn.charAt(index) - '0';
            sum += (digit * (10 - index));
        }

        // if the last character is 'X', add 10 to sum, else add its value
        sum += (lastCharacterIsX ? 10 : (isbn.charAt(isbnLength - 1) - '0'));

        return (sum % 11 == 0);  // return whether weighted sum is divisible by 11
    }

    /**
     * This gets the checkBit of the valid first 12 digits of an isbn13
     * @param isbn book isbn
     * @return
     *      valid checkBit if computation was successful
     *      null otherwise
     */
    public static String getIsbn13CheckBit(String isbn) {
        if (isbn == null) {
            return null;
        }

        // remove spaces and dashes from isbn
        isbn = isbn.replace("-", "")
                .replace(" ", "").toUpperCase();
        int isbnLength = isbn.length();

        // return null if isbn digits are not numbers
        if (isNotDigit(isbn)) {
            return null;
        }

        if ((isbnLength < 12) ||                          // if isbn isn't starting digits of isbn13
                !(isbn.substring(0, 3).equals("978"))) {  // if first 3 digits of isbn are incorrect
            return null;
        }

        int odd = 0;
        int even = 0;
        int checkBit;

        // convert isbn string into array of integers
        int[] isbnIntArray = isbn.chars().map(strDigit -> strDigit - '0').toArray();

        // perform the isbn13 checkBit computation
        for (int index = 0; index < 6; index++) {
            even += isbnIntArray[2 * index];
            odd += isbnIntArray[(2 * index) + 1] * 3;
        }
        int isbnModulo = (even + odd) % 10;
        checkBit = (isbnModulo == 0) ? 0 : (10 - isbnModulo);

        // return the checkBit
        return String.valueOf(checkBit);
    }

    /**
     * This checks if an isbn is valid isbn13
     * @param isbn book isbn
     * @return
     *      true if isbn is valid isbn13
     *      false otherwise
     */
    public static boolean isValidIsbn13(String isbn) {
        if (isbn == null) {
            return false;
        }

        // remove spaces and dashes from isbn
        isbn = isbn.replace("-", "")
                .replace(" ", "").toUpperCase();

        int isbnLength = isbn.length();

        if (isbnLength != 13) {  // isbn13 has to be 13 digits
            return false;
        }

        // return false if isbn13 digits are not numbers
        if (isNotDigit(isbn)) {
            return false;
        }

        String lastCharacter = Character.toString(isbn.charAt(isbnLength - 1));
        String checkBit = getIsbn13CheckBit(isbn);

        // input isbn13 is valid if computed checkBit is equal to its last character
        return (lastCharacter.equals(checkBit));
    }

    /**
     * This converts isbn10 or isbn13 to valid isbn13, if possible
     * @param isbn book isbn
     * @return
     *      valid isbn13 if conversion was successful
     *      null otherwise
     */
    public static String convertToIsbn13(String isbn) {
        if (isbn == null) {
            return null;
        }

        // remove spaces and dashes from isbn
        isbn = isbn.replace("-", "")
                .replace(" ", "").toUpperCase();

        int isbnLength = isbn.length();

        if ((isbnLength != 10) && (isbnLength != 13)) {  // if input is not isbn10 or isbn13
            return null;
        }

        if ((isbnLength == 13) && isValidIsbn13(isbn)) {  // return valid isbn13 on isbn13 input
            return isbn;
        }

        // convert isbn10 to isbn13 if isbn10 is valid
        if ((isbnLength == 10) && isValidIsbn10(isbn)) {
            String isbnWithoutLastCharacter = isbn.substring(0, isbnLength - 1);
            isbn = "978" + isbnWithoutLastCharacter;
            String checkBit = getIsbn13CheckBit(isbn);

            if (checkBit != null) {
                isbn += checkBit;
                return isbn;
            }
            return null;
        }

        return null;

    }

    public static boolean isValidRequesters(ArrayList<String> requesters) {
        if (requesters == null) {
            return false;
        }

        for (String requester : requesters) {
            if (!isValidUserEmail(requester)) {
                return false;
            }
        }
        return true;
    }

    public static String generateValidId() {
        String CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        StringBuilder validId = new StringBuilder();

        for (int i = 0; i < 20; i++) {
            validId.append(CHARS.charAt((new Random()).nextInt(CHARS.length())));
        }

        return validId.toString();
    }

    /////////////////////////////////////////  USER PARSER /////////////////////////////////////////

    /**
     * This returns a valid User object if arguments are valid, null otherwise
     * @param firstName user first name
     * @param lastName user last name
     * @param email user email
     * @param username user username
     * @param password user password
     * @param photo user photo
     * @return
     *      valid User object if arguments are valid
     *      null otherwise
     */
    public static User parseUser(String firstName, String lastName, String email, String username,
                                 String password, String phoneNumber, String photo) {
        // return null if non-optional fields are null
        if ((firstName == null) || (lastName == null) || (email == null)
                || (username == null) || (password == null)) {
            return null;
        }

        firstName = firstName.trim();
        lastName = lastName.trim();
        email = email.trim().toLowerCase();
        username = username.trim();
        password = password.trim();
        phoneNumber = (phoneNumber == null) ? "" : phoneNumber.trim();  // replace null
        photo = (photo == null) ? "" : photo.trim();  // replace null with empty string

        // if all fields are valid
        if (isValidFirstName(firstName) && isValidLastName(lastName)
                && isValidUserEmail(email) && isValidUsername(username)
                && isValidPassword(password) && isValidPhoneNumber(phoneNumber)
                && isValidUserPhoto(photo)) {

            // return a new User object if all fields are valid
            return new User(firstName, lastName, email, username, password, phoneNumber, photo);
        }

        // return null if not all fields are valid
        return null;
    }

    /**
     * This checks whether or not a user HashMap object contains valid User data
     * @param userMapObject a HashMap object containing User data
     * @return
     *      true if the user HashMap object contains valid User data
     *      false otherwise
     */
    public static boolean isValidUser(HashMap<String, Object> userMapObject) {
        // get all values
        String firstName = (String) userMapObject.get("firstName");
        String lastName = (String) userMapObject.get("lastName");
        String email = (String) userMapObject.get("email");
        String username = (String) userMapObject.get("username");
        String password = (String) userMapObject.get("password");
        String phoneNumber = (String) userMapObject.get("phoneNumber");
        String photo = (String) userMapObject.get("photo");

        // if all fields (other than isbn) are valid
        if (isValidFirstName(firstName) && isValidLastName(lastName)
                && isValidUserEmail(email) && isValidUsername(username)
                && isValidPassword(password) && isValidPhoneNumber(phoneNumber)
                && isValidUserPhoto(photo)) {

            // return whether or not all fields are valid
            return true;

        }

        Log.e("PARSER_VALID_USER", email + " is not valid!"
                + " " + "firstName:" + isValidFirstName(firstName)
                + " " + "lastName:" + isValidLastName(lastName)
                + " " + "email:" + isValidUserEmail(email)
                + " " + "username:" + isValidUsername(username)
                + " " + "password:" + isValidPassword(password)
                + " " + "phoneNumber:" + isValidPhoneNumber(phoneNumber)
                + " " + "photo:" + isValidUserPhoto(photo)
        );

        // return null if not all fields are valid
        return false;
    }

    /**
     * This checks whether or not a user object contains valid User data
     * @param userObject a user object containing User data
     * @return
     *      true if the user object contains valid User data
     *      false otherwise
     */
    public static boolean isValidUserObject(User userObject) {
        // get all values
        String firstName = userObject.getFirstName();
        String lastName = userObject.getLastName();
        String email = userObject.getEmail();
        String username = userObject.getUsername();
        String password = userObject.getPassword();
        String phoneNumber = userObject.getPhoneNumber();
        String photo = userObject.getPhoto();

        // if all fields (other than isbn) are valid
        if (isValidFirstName(firstName) && isValidLastName(lastName)
                && isValidUserEmail(email) && isValidUsername(username)
                && isValidPassword(password) && isValidPhoneNumber(phoneNumber)
                && isValidUserPhoto(photo)) {

            // return whether or not all fields are valid
            return true;

        }

        Log.e("PARSER_VALID_USER", email + " is not valid!"
                + " " + "firstName:" + isValidFirstName(firstName)
                + " " + "lastName:" + isValidLastName(lastName)
                + " " + "email:" + isValidUserEmail(email)
                + " " + "username:" + isValidUsername(username)
                + " " + "password:" + isValidPassword(password)
                + " " + "phoneNumber:" + isValidPhoneNumber(phoneNumber)
                + " " + "photo:" + isValidUserPhoto(photo)
        );

        // return null if not all fields are valid
        return false;
    }

    public static boolean isValidUserData(String firstName, String lastName, String email,
                                          String username, String password,
                                          String phoneNumber, String photo) {

        // return false if non-optional fields are null
        if ((firstName == null) || (lastName == null) || (email == null)
                || (username == null) || (password == null)) {
            return false;
        }

        // return true if all fields are valid
        return isValidFirstName(firstName) && isValidLastName(lastName)
                && isValidUserEmail(email) && isValidUsername(username)
                && isValidPassword(password) && isValidPhoneNumber(phoneNumber)
                && isValidUserPhoto(photo);
    }

    /**
     * This checks if a user firstName is valid
     * @param firstName user firstName
     * @return
     *      true if firstName is not null or an empty string
     *      false otherwise
     */
    public static boolean isValidFirstName(String firstName) {
        return ((firstName != null) && (firstName.trim().length() > 0));
    }

    /**
     * This checks if a user lastName is valid
     * @param lastName user lastName
     * @return
     *      true if lastName is not null or an empty string
     *      false otherwise
     */
    public static boolean isValidLastName(String lastName) {
        return ((lastName != null) && (lastName.trim().length() > 0));
    }

    /**
     * This checks if a user email is valid
     * @param email app user's email
     * @return
     *      true if email is formatted correctly, not null or an empty string, and is lowercase
     *      false otherwise
     */
    public static boolean isValidUserEmail(String email) {
        return isValidEmail(email);
    }

    /**
     * This checks if a user username is valid
     * @param username user username
     * @return
     *      true if username is not null or an empty string
     *      false otherwise
     */
    public static boolean isValidUsername(String username) {
        return ((username != null) && (username.trim().length() > 0));
    }

    /**
     * This checks if a user password is valid
     * @param password user password
     * @return
     *      true if password is not null or less than 6 characters
     *      false otherwise
     */
    public static boolean isValidPassword(String password) {
        return ((password != null) && (password.trim().length() >= 6));
    }

    /**
     * This checks if a user phoneNumber is valid
     * @param phoneNumber user phoneNumber
     * @return
     *      true if phoneNumber a non-null number with a length of [5, 15]
     *      false otherwise
     */
    public static boolean isValidPhoneNumber(String phoneNumber) {
        return (((phoneNumber != null) && ((phoneNumber.equals("")) || (!isNotDigit(phoneNumber))
                && (phoneNumber.trim().length() > 4) && (phoneNumber.trim().length() < 16))));
    }

    /**
     * This checks if a photo name is valid
     * @param photo name of app user's optional photo
     * @return
     *      true if photo is an empty string or a jpg file
     *      false otherwise
     */
    public static boolean isValidUserPhoto(String photo) {
        if (photo == null) {
            return false;
        }
        return photo.equals("") || (photo.endsWith(".jpg") && (photo.length() > 4));
    }

    /**
     * This checks if a user list of owned books is valid
     * @param ownedBooks user list of owned books
     * @return
     *      true if every id in the list of owned books is valid
     *      false otherwise
     */
    public static boolean isValidOwnedBooksList(ArrayList<String> ownedBooks) {
        if (ownedBooks == null) {
            return false;
        }

        for (String id : ownedBooks) {
            if (!isValidBookId(id) || (id.equals(""))) {
                return false;
            }
        }
        return true;
    }

    /**
     * This checks if a user list of requested books is valid
     * @param requestedBooks user list of requested books
     * @return
     *      true if every id in the list of requested books is valid
     *      false otherwise
     */
    public static boolean isValidRequestedBooksList(ArrayList<String> requestedBooks) {
        if (requestedBooks == null) {
            return false;
        }

        for (String id : requestedBooks) {
            if (!isValidBookId(id) || (id.equals(""))) {
                return false;
            }
        }
        return true;
    }

    /**
     * This checks if a user list of accepted books is valid
     * @param acceptedBooks user list of accepted books
     * @return
     *      true if every id in the list of accepted books is valid
     *      false otherwise
     */
    public static boolean isValidAcceptedBooksList(ArrayList<String> acceptedBooks) {
        if (acceptedBooks == null) {
            return false;
        }

        for (String id : acceptedBooks) {
            if (!isValidBookId(id) || (id.equals(""))) {
                return false;
            }
        }
        return true;
    }

    /**
     * This checks if a user list of borrowed books is valid
     * @param borrowedBooks user list of borrowed books
     * @return
     *      true if every id in the list of borrowed books is valid
     *      false otherwise
     */
    public static boolean isValidBorrowedBooksList(ArrayList<String> borrowedBooks) {
        if (borrowedBooks == null) {
            return false;
        }

        for (String id : borrowedBooks) {
            if (!isValidBookId(id) || (id.equals(""))) {
                return false;
            }
        }
        return true;
    }

    ////////////////////////////////////////  REQUEST PARSER ///////////////////////////////////////

    /**
     * This returns a valid Request object if arguments are valid, null otherwise
     * @param requester requester email
     * @param requestee requestee email
     * @param requestedBook requested book id
     * @return
     *      valid Request object if arguments are valid
     *      null otherwise
     */
//    public static Request parseRequest(String requester, String requestee,
//                                       String requestedBook, String requestDate) {
//        // return null if fields are null
//        if ((requester == null) || (requestee == null)
//                || (requestedBook == null) || (requestDate == null)) {
//            return null;
//        }
//
//        // trim all values
//        requester = requester.trim();
//        requestee = requestee.trim();
//        requestedBook = requestedBook.trim();
//
//        // if all fields are valid
//        if (isValidBookRequester(requester) && isValidBookRequestee(requestee)
//                && isValidRequestedBook(requestedBook) && isValidRequestDate(requestDate)) {
//
//            Request requestObject = new Request(requester, requestee, requestedBook, requestDate);
//
//            if (isValidRequestDate(requestObject.getRequestDate())) {
//
//                // return a new Request object if all fields are valid
//                return requestObject;
//            }
//        }
//
//        // return null if not all fields are valid
//        return null;
//
//    }

    /**
     * This returns a valid Request object if arguments are valid, null otherwise
     * @param requester requester email
     * @param requestee requestee email
     * @param requestedBookObject requested book object
     * @return
     *      valid Request object if arguments are valid
     *      null otherwise
     */
    public static Request parseRequest(String requester, String requestee,
                                       Book requestedBookObject) {
        // return null if non-optional fields are null
        if ((requester == null) || (requestee == null) || (requestedBookObject == null)) {
            return null;
        }

        // trim all values
        requester = requester.trim();
        requestee = requestee.trim();

        // if all fields are valid
        if (isValidBookRequester(requester) && isValidBookRequestee(requestee)
                && isValidRequestedBookObject(requestedBookObject)) {

            Request requestObject = new Request(requester, requestee, requestedBookObject, null);

            if (isValidRequestDate(requestObject.getRequestDate())) {

                // return a new Request object if all fields are valid
                return requestObject;
            }
        }

        // return null if not all fields are valid
        return null;

    }

    /**
     * This checks whether or not a request HashMap object contains valid Request data
//     * @param requestMapObject a HashMap object containing Request data
     * @return
     *      true if the request HashMap object contains valid Request data
     *      false otherwise
     */
    public static boolean isValidRequest(HashMap<String, Object> requestMapObject) {
        // get all values
        String requester = (String) requestMapObject.get("requester");
        String requestee = (String) requestMapObject.get("requestee");
        String requestedBook = (String) requestMapObject.get("requestedBook");
        String requestDate = (String) requestMapObject.get("requestDate");

        // if all fields are valid
        if (isValidBookRequester(requester) && isValidBookRequestee(requestee)
                && isValidRequestedBook(requestedBook) && isValidRequestDate(requestDate)) {

            // return whether or not all fields are valid
            return true;

        }

        Log.e("PARSER_VALID_REQUEST", requester + " is not valid!"
                + " " + "requester:" + isValidBookRequester(requester)
                + " " + "requestee:" + isValidBookRequestee(requestee)
                + " " + "requestedBook:" + isValidRequestedBook(requestedBook)
                + " " + "requestDate:" + isValidRequestDate(requestDate)
        );

        // return null if not all fields are valid
        return false;
    }

    public static boolean isValidRequestObject(Request requestObject) {
        // get all values
        String requester = requestObject.getRequester();
        String requestee = requestObject.getRequestee();
        Book requestedBook = requestObject.getRequestedBookObject();
        String requestDate = requestObject.getRequestDate();

        // if all fields are valid
        if (isValidBookRequester(requester) && isValidBookRequestee(requestee)
                && isValidRequestedBookObject(requestedBook) && isValidRequestDate(requestDate)) {

            // return whether or not all fields are valid
            return true;

        }

        Log.e("PARSER_VALID_REQUEST", requester + " is not valid!"
                + " " + "requester:" + isValidBookRequester(requester)
                + " " + "requestee:" + isValidBookRequestee(requestee)
                + " " + "requestedBook:" + isValidRequestedBook(requestedBook.getId())
                + " " + "requestDate:" + isValidRequestDate(requestDate)
        );

        // return null if not all fields are valid
        return false;
    }

    public static boolean isValidRequestWithBookIdObject(Request requestObject) {
        // get all values
        String requester = requestObject.getRequester();
        String requestee = requestObject.getRequestee();
        String requestedBook = requestObject.getRequestedBook();
        String requestDate = requestObject.getRequestDate();

        // if all fields are valid
        if (isValidBookRequester(requester) && isValidBookRequestee(requestee)
                && isValidRequestedBook(requestedBook) && isValidRequestDate(requestDate)) {

            // return whether or not all fields are valid
            return true;

        }

        Log.e("PARSER_VALID_REQUEST", requester + " is not valid!"
                + " " + "requester:" + isValidBookRequester(requester)
                + " " + "requestee:" + isValidBookRequestee(requestee)
                + " " + "requestedBook:" + isValidRequestedBook(requestedBook)
                + " " + "requestDate:" + isValidRequestDate(requestDate)
        );

        // return null if not all fields are valid
        return false;
    }

    public static boolean isValidRequestData(String requester, String requestee,
                                             Book requestedBookObject, String requestDate) {

        // return false if non-optional fields are null
        if ((requester == null) || (requestee == null) || (requestedBookObject == null)) {
            return false;
        }

        // trim all values
        requester = requester;  // lowercase email
        requestee = requestee;  // lowercase email
        requestDate = requestDate.trim();

        // return true if all fields are valid
        return (isValidBookRequester(requester) && isValidBookRequestee(requestee)
                && isValidRequestedBookObject(requestedBookObject)
                && isValidRequestDate(requestDate));
    }

    /**
     * This checks if a requester email is valid
     * @param requester requester's email
     * @return
     *      true if requester email is not null or an empty string and is lowercase
     *      false otherwise
     */
    public static boolean isValidBookRequester(String requester) {
        return (requester != null) && (!requester.equals(""))
                && requester.equals(requester.toLowerCase());
    }

    /**
     * This checks if a requestee email is valid
     * @param requestee requestee's email
     * @return
     *      true if requestee email is not null or an empty string and is lowercase
     *      false otherwise
     */
    public static boolean isValidBookRequestee(String requestee) {
        return (requestee != null) && (!requestee.equals(""))
                && requestee.equals(requestee.toLowerCase());
    }

    /**
     * This checks if a requested book id is valid
     * @param requestedBook book id that was randomly generated by Firebase
     * @return
     *      true if empty string or valid id
     *      false otherwise
     */
    public static boolean isValidRequestedBook(String requestedBook) {
        return ((requestedBook != null) && (requestedBook.trim().length() > 0));
    }

    /**
     * This checks if a requested book object is valid
     * @param requestedBookObject requested book object
     * @return
     *      true if requested book object is valid
     *      false otherwise
     */
    public static boolean isValidRequestedBookObject(Book requestedBookObject) {
        return isValidBookObject(requestedBookObject);
    }

    /**
     * This checks if a request date is valid
     * @param requestDate date that a request was made
     * @return
     *      true if request date is valid
     *      false otherwise
     */
    public static boolean isValidRequestDate(String requestDate) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm",
                Locale.CANADA);
        dateFormat.setLenient(false);
        try {
            dateFormat.parse(requestDate);
        } catch (ParseException pe) {
            return false;
        }
        return true;
    }

    /////////////////////////////////////  NOTIFICATION PARSER /////////////////////////////////////

    /**
     * This returns a valid Notification object if arguments are valid, null otherwise
     * @param message notification message
     * @param sender sender's email
     * @param receiver receiver's email
     * @param relatedBook book id that was randomly generated by Firebase
     * @param seen true or false, depending on whether or not the notification has been seen
     * @param type notification type
     * @return
     *      valid Notification object if arguments are valid
     *      null otherwise
     */
    public static Notification parseNotification(String message, String sender, String receiver,
                                                 String relatedBook, boolean seen, String type) {

        // return null if fields are null
        if ((message == null) || (sender == null) || (receiver == null)
                || (relatedBook == null) || (type == null)) {
            return null;
        }

        // trim all values
        message = message.trim();
        sender = sender.trim();
        receiver = receiver.trim();
        relatedBook = relatedBook.trim();
        type = type.trim();

        // if all fields are valid
        if (isValidNotificationMessage(message) && isValidNotificationSender(sender)
                && isValidNotificationReceiver(receiver)
                && isValidRelatedBook(relatedBook)
                && isValidNotificationType(type)) {

            Notification notificationObject = new Notification(message, sender, receiver,
                    relatedBook, seen, type);

            if (isValidNotificationDate(notificationObject.getNotificationDate())) {

                // return a new Notification object if all fields are valid
                return notificationObject;
            }
        }

        // return null if not all fields are valid
        return null;
    }

    /**
     * This checks whether or not a notification HashMap object contains valid Notification data
     * @param notificationMapObject a HashMap object containing Notification data
     * @return
     *      true if the notification HashMap object contains valid Notification data
     *      false otherwise
     */
    public static boolean isValidNotification(HashMap<String, Object> notificationMapObject) {
        // get all values
        String message = (String) notificationMapObject.get("message");
        String sender = (String) notificationMapObject.get("sender");
        String receiver = (String) notificationMapObject.get("receiver");
        String relatedBook = (String) notificationMapObject.get("relatedBook");
        String type = (String) notificationMapObject.get("type");
        String notificationDate = (String) notificationMapObject.get("notificationDate");

        // if all fields are valid
        if (isValidNotificationMessage(message) && isValidNotificationSender(sender)
                && isValidNotificationReceiver(receiver)
                && isValidRelatedBook(relatedBook)
                && isValidNotificationType(type)) {

            // return whether or not all fields are valid
            return true;

        }

        Log.e("PARSER_VALID_NOTIFICATION", message + " is not valid!"
                + " " + "message:" + isValidNotificationMessage(message)
                + " " + "sender:" + isValidNotificationSender(sender)
                + " " + "relatedBook:" + isValidRelatedBook(relatedBook)
                + " " + "notificationDate:" + isValidNotificationDate(notificationDate)
        );

        // return null if not all fields are valid
        return false;
    }

    /**
     * This checks if a notification message is valid
     * @param message notification message
     * @return
     *      true if message is not null or an empty string
     *      false otherwise
     */
    public static boolean isValidNotificationMessage(String message) {
        return ((message != null) && (message.trim().length() > 0));
    }

    /**
     * This checks if a sender email is valid
     * @param sender sender's email
     * @return
     *      true if sender email is not null or an empty string and is lowercase
     *      false otherwise
     */
    public static boolean isValidNotificationSender(String sender) {
        return (sender != null) && (!sender.equals(""))
                && sender.equals(sender.toLowerCase());
    }

    /**
     * This checks if a receiver email is valid
     * @param receiver receiver's email
     * @return
     *      true if receiver email is not null or an empty string and is lowercase
     *      false otherwise
     */
    public static boolean isValidNotificationReceiver(String receiver) {
        return (receiver != null) && (!receiver.equals(""))
                && receiver.equals(receiver.toLowerCase());
    }

    /**
     * This checks if a related book id is valid
     * @param relatedBook book id that was randomly generated by Firebase
     * @return
     *      true if empty string or valid id
     *      false otherwise
     */
    public static boolean isValidRelatedBook(String relatedBook) {
        return ((relatedBook != null) && (relatedBook.trim().length() > 0));
    }

    /**
     * This checks if the notification type specified is in the list of notification types
     * @param type notification type
     * @return
     *      true if type is in ["BOOK_REQUESTED", "REQUEST_ACCEPTED", "REQUEST_DECLINED",
     *             "RETURN_REQUESTED", "LOCATION_SPECIFIED"]
     *      false otherwise
     */
    public static boolean isValidNotificationType(String type) {
        return notificationTypes.contains(type);
    }

    /**
     * This checks if a notification date is valid
     * @param notificationDate date that a notification was made
     * @return
     *      true if notification date is valid
     *      false otherwise
     */
    public static boolean isValidNotificationDate(String notificationDate) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm",
                Locale.CANADA);
        dateFormat.setLenient(false);
        try {
            dateFormat.parse(notificationDate);
        } catch (ParseException pe) {
            return false;
        }
        return true;
    }

    // TODO: EXCHANGE PARSER
    ///////////////////////////////////////  EXCHANGE PARSER ///////////////////////////////////////

    public static boolean isValidExchangeData(String exchangeId, String relatedBook,
                                              String owner, String borrower,
                                              String ownerBookStatus, String borrowerBookStatus,
                                              MeetingDetails meetingDetails) {

        // return false if non-optional fields are null
        if ((exchangeId == null) || (owner == null) || (relatedBook == null)
                || (borrower == null) || (ownerBookStatus == null)
                || (borrowerBookStatus == null) || (meetingDetails == null)) {
            return false;
        }

        // trim all values
        exchangeId = exchangeId.trim();
        relatedBook = relatedBook.trim();
        owner = owner.trim();
        borrower = borrower.trim();
        ownerBookStatus = ownerBookStatus.trim();
        borrowerBookStatus = borrowerBookStatus.trim();

        Log.e("PARSER_VALID_MEETING", exchangeId + " is not valid!"
                + " " + "exchangeId:" + isValidMeetingExchangeId(exchangeId)
                + " " + "relatedBook:" + isValidMeetingExchangeId(relatedBook)
                + " " + "owner:" + isValidUserEmail(owner)
                + " " + "borrower:" + isValidUserEmail(borrower)
                + " " + "ownerBookStatus:" + isValidExchangeStatus(ownerBookStatus)
                + " " + "borrowerBookStatus:" + isValidExchangeStatus(borrowerBookStatus)
                + " " + "meetingDetails:" + isValidMeetingObject(meetingDetails)
        );

        // return true if all fields are valid
        return (isValidMeetingExchangeId(exchangeId) && isValidBookId(relatedBook)
                && isValidUserEmail(owner) && isValidUserEmail(borrower)
                && isValidExchangeStatus(ownerBookStatus)
                && isValidExchangeStatus(borrowerBookStatus)
                && isValidMeetingObject(meetingDetails));
    }

    /**
     * This checks if the status specified is in the list of statuses
     * @param status exchange status
     * @return
     *      true if status is in ["AVAILABLE", "ACCEPTED", "BORROWED"]
     *      false otherwise
     */
    public static boolean isValidExchangeStatus(String status) {
        return statuses.contains(status) && (!(status.equals("REQUESTED")));
    }

    // TODO: MeetingDetails PARSER
    ////////////////////////////////////  MeetingDetails PARSER ////////////////////////////////////

    public static boolean isValidMeetingData(double latitude,
                                             double longitude, String address,
                                             String meetingDate, String meetingTime) {

        // return false if non-optional fields are null
        if ((address == null)
                || (meetingDate == null) || (meetingTime == null)) {
            return false;
        }

        // trim all values
        address = address.trim();
        meetingDate = meetingDate.trim();
        meetingTime = meetingTime.trim();

        Log.e("PARSER_VALID_MEETING", address + " is not valid!"
                + " " + "address:" + isValidMeetingAddress(address)
                + " " + "meetingDate:" + isValidMeetingDate(meetingDate)
                + " " + "meetingTime:" + isValidMeetingTime(meetingDate, meetingTime)
        );

        // return true if all fields are valid
        return (isValidMeetingAddress(address)
                /*&& isValidMeetingLatitude(latitude) && isValidMeetingLongitude(longitude)*/
                && isValidMeetingDate(meetingDate) && isValidMeetingTime(meetingDate, meetingTime));
    }

    public static boolean isValidMeetingObject(MeetingDetails meetingDetails) {

        String address = meetingDetails.getAddress();
        String meetingDate = meetingDetails.getMeetingDate();
        String meetingTime = meetingDetails.getMeetingTime();

        // return false if non-optional fields are null
        if ((address == null) || (meetingDate == null) || (meetingTime == null)) {
            return false;
        }

        // trim all values
        address = address.trim();
        meetingDate = meetingDate.trim();
        meetingTime = meetingTime.trim();

        Log.e("PARSER_VALID_MEETING", address + " is not valid!"
                + " " + "address:" + isValidMeetingAddress(address)
                + " " + "meetingDate:" + isValidMeetingDate(meetingDate)
                + " " + "meetingTime:" + isValidMeetingTime(meetingDate, meetingTime)
        );

        // return true if all fields are valid
        return (isValidMeetingAddress(address)
                /*&& isValidMeetingLatitude(latitude) && isValidMeetingLongitude(longitude)*/
                && isValidMeetingDate(meetingDate) && isValidMeetingTime(meetingDate, meetingTime));
    }

    /**
     * This checks if a meeting id is valid
     * @param id meeting id
     * @return
     *      true if valid id
     *      false otherwise
     */
    public static boolean isValidMeetingExchangeId(String id) {
        return ((id != null) && (id.trim().length() > 0));
    }

    /**
     * This checks if a meeting address is valid
     * @param address meeting address
     * @return
     *      true if valid address
     *      false otherwise
     */
    public static boolean isValidMeetingAddress(String address) {
        return ((address != null) && (address.trim().length() > 0));
    }

    public static boolean isValidMeetingDate(String meetingDate) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd",
                Locale.CANADA);
        dateFormat.setLenient(false);

        Date mDate;
        Date currentDate;

        try {
            mDate = dateFormat.parse(meetingDate);
            currentDate = dateFormat.parse(dateFormat.format(new Date()));
        } catch (ParseException pe) {
            return false;
        }
        return (mDate != null) && (currentDate != null)
                && (mDate.equals(currentDate) || mDate.after(currentDate));
    }

    public static boolean isValidMeetingTime(String meetingDate, String meetingTime) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm",
                Locale.CANADA);
        dateFormat.setLenient(false);
        try {
            dateFormat.parse(meetingTime);
        } catch (ParseException pe) {
            return false;
        }

        SimpleDateFormat dateTimeFormat = null;
        if ((meetingDate != null) && !(meetingDate.equals(""))) {
            dateTimeFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm",
                    Locale.CANADA);
        }

        try {
            if (dateTimeFormat != null) {
                Date mDate = dateTimeFormat.parse(meetingDate + " " + meetingTime);
                Date currentDate = dateTimeFormat.parse(dateTimeFormat.format(new Date()));

                return (mDate != null) && (currentDate != null)
                        && (mDate.equals(currentDate) || mDate.after(currentDate));
            }
        } catch (ParseException pe) {
            return false;
        }

        return true;
    }
}
